import logging
from typing import Any, Dict, List, Optional
from urllib.parse import urlparse

logger = logging.getLogger(__name__)


class CompetitiveIntelService:
    """Helper utilities for competitor coverage signals derived from search results."""

    @staticmethod
    def _normalize_domain(value: str) -> str:
        if not value:
            return ""
        raw = value.strip().lower()
        if "://" not in raw:
            raw = f"https://{raw}"
        try:
            domain = urlparse(raw).netloc.lower()
        except Exception:
            return ""
        if domain.startswith("www."):
            domain = domain[4:]
        return domain

    @staticmethod
    def build_competitor_query_coverage(
        search_results: Dict[str, Any],
        competitor_audits: List[Dict[str, Any]],
        target_audit: Optional[Dict[str, Any]] = None,
        max_competitors: int = 5,
        max_samples: int = 3,
    ) -> Dict[str, Any]:
        if not isinstance(search_results, dict) or not search_results:
            return {
                "status": "insufficient_data",
                "reason": "No search_results provided for competitor coverage.",
            }

        domains: Dict[str, Dict[str, Any]] = {}

        def add_domain(domain_value: str, label: Optional[str] = None):
            domain = CompetitiveIntelService._normalize_domain(domain_value)
            if not domain:
                return
            if domain not in domains:
                domains[domain] = {
                    "domain": domain,
                    "label": label or domain,
                    "queries": [],
                    "sample_urls": [],
                }

        for comp in competitor_audits or []:
            if isinstance(comp, dict):
                add_domain(comp.get("url") or comp.get("domain"), comp.get("domain"))

        if target_audit and isinstance(target_audit, dict):
            competitors = target_audit.get("competitors")
            if isinstance(competitors, list):
                for comp in competitors:
                    add_domain(str(comp))

        if not domains:
            return {
                "status": "insufficient_data",
                "reason": "No competitor domains available to compute coverage.",
            }

        total_queries = len(search_results)
        for query, result in search_results.items():
            if not isinstance(result, dict):
                continue
            items = result.get("items", [])
            if not isinstance(items, list):
                continue
            seen_domains = set()
            for item in items[:10]:
                if not isinstance(item, dict):
                    continue
                link = item.get("link")
                if not link:
                    continue
                domain = CompetitiveIntelService._normalize_domain(link)
                if not domain or domain in seen_domains:
                    continue
                if domain in domains:
                    domains[domain]["queries"].append(query)
                    if len(domains[domain]["sample_urls"]) < max_samples:
                        domains[domain]["sample_urls"].append(link)
                    seen_domains.add(domain)

        coverage_list = []
        for domain, data in domains.items():
            query_hits = len(set(data["queries"]))
            coverage_list.append(
                {
                    "competitor": data["label"] or domain,
                    "domain": domain,
                    "queries_appeared": query_hits,
                    "appearance_rate_percent": round(
                        (query_hits / max(1, total_queries)) * 100, 1
                    ),
                    "sample_queries": sorted(set(data["queries"]))[:max_samples],
                    "sample_urls": data["sample_urls"][:max_samples],
                }
            )

        coverage_list.sort(
            key=lambda x: (x["queries_appeared"], x["appearance_rate_percent"]),
            reverse=True,
        )
        coverage_list = coverage_list[: max(1, int(max_competitors))]

        return {
            "status": "ok",
            "data_source": "Google CSE top results for competitor discovery queries",
            "total_queries": total_queries,
            "coverage_by_competitor": coverage_list,
            "limitations": [
                "Proxy signal only; not a true ranking dataset.",
                "Queries are limited to those generated by the competitor discovery step.",
            ],
        }
